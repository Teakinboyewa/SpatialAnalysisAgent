## -*- coding: utf-8 -*-
"""
/***************************************************************************
 Spatial_Analysis_AgentDockWidget
                                 A QGIS plugin
 A plugin integration between QGIS and Large Language Model (LLM) for Spatial Analysis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-08-12
        git sha              : $Format:%H$
        copyright            : (C) 2024 by GIBD
        email                : teakinboyewa@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import base64
import configparser
import importlib
import os
import shutil
import sys

import requests
from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal
from qgis.PyQt.QtCore import QSettings
import subprocess
import re
from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal
import configparser
import os
import sys
import subprocess
from io import StringIO
import time
from PyQt5.QtWebKitWidgets import QWebView
from qgis.PyQt.QtCore import Qt, QCoreApplication
from qgis._core import QgsVectorLayer, QgsRasterLayer
QCoreApplication.setAttribute(Qt.AA_ShareOpenGLContexts)
from PyQt5.QtWidgets import QDialog, QFileDialog, QTextEdit, QApplication, QWidget, QSizeGrip, QMessageBox, QInputDialog
from PyQt5.QtCore import QThread, pyqtSignal, QUrl, QObject, pyqtSlot, QPropertyAnimation, QPoint, QRect, QSettings
from PyQt5 import QtWidgets, uic
from PyQt5.QtWidgets import QDialog, QHBoxLayout
import os
import sys
import subprocess
import traceback
from PyQt5.QtWidgets import QApplication, QVBoxLayout, QHBoxLayout, QGridLayout, QWidget, QTextEdit, QPushButton, \
    QLabel, QLineEdit, QMenu, QAction, QCompleter
from PyQt5.QtCore import QThread, pyqtSignal
from PyQt5.QtGui import QTextCursor, QTextCharFormat, QFont, QColor, QPainter, QBrush, QSyntaxHighlighter
import asyncio
from qgis.gui import QgsMapCanvas, QgsLayerTreeView, QgsLayerTreeMapCanvasBridge, QgsAttributeDialog
from qgis.core import QgsProject, QgsLayerTreeModel, QgsLayerTreeNode, QgsRectangle
from qgis.core import QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsProject, QgsVectorLayer, \
    QgsCoordinateTransformContext, QgsGeometry, QgsFeature, QgsVectorFileWriter


FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'SpatialAnalysisAgent_dockwidget_base.ui'))

current_script_dir = os.path.dirname(os.path.abspath(__file__))
from .install_packages.check_packages import check_and_install_libraries , check_missing_libraries, read_libraries_from_file, install_libraries
class LibraryCheckThread(QThread):
    finished_checking = pyqtSignal(list)

    def __init__(self, filename):
        QThread.__init__(self)
        self.filename = filename

    def run(self):
        # Perform the library check in this thread
        missing_packages = check_missing_libraries(read_libraries_from_file(self.filename))
        self.finished_checking.emit(missing_packages)


class SpatialAnalysisAgentDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(SpatialAnalysisAgentDockWidget, self).__init__(parent)

        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect

        # Perform the library check only once

        # Initialization of your plugin
        # self.contribution_dialog = None  # Initialize ContributionDialog later

        # Add this to your pluginâ€™s UI (like a menu or button)
        # self.contribute_action = QAction("Contribute", self.iface.mainWindow())
        # self.contribute_action.clicked.connect(self.show_contribution_dialog)



        self.setupUi(self)

        from .install_packages.check_packages import check_and_install_libraries
        # Run the check before the class definition
        current_script_dir = os.path.dirname(os.path.abspath(__file__))
        required_packages = os.path.join(current_script_dir, 'install_packages', 'requirements.txt')

        # check_and_install_libraries(required_packages)

        self.thread = LibraryCheckThread(required_packages)
        self.thread.finished_checking.connect(self.handle_missing_libraries)
        self.thread.start()  # Start the background thread

        self.import_libraries()

        self.load_OpenAI_key()


        self.initUI()
        # Connect to layer added and removed signals
        QgsProject.instance().layerWasAdded.connect(self.on_layer_added)
        QgsProject.instance().layerWillBeRemoved.connect(self.on_layer_removed)

        self.thread = None  # Initialize thread variable
        self.interrupt_button.clicked.connect(self.interrupt)
        # Set the window size
        self.resize(800, 600)

        # Ensure the window has minimize and maximize buttons
        self.setWindowFlags(self.windowFlags() |
                            Qt.WindowMinimizeButtonHint |
                            Qt.WindowMaximizeButtonHint)

        # Initialize conversation history
        self.conversation_history = []
        self.task_history = []
        self.data_path_history = []

        self.stopFlag = False
        self.interrupt_button.clicked.connect(self.interrupt)

        # Initialize QCompleter for task_LineEdit
        self.task_completer = QCompleter(self.task_history, self)
        self.task_completer.setCaseSensitivity(Qt.CaseInsensitive)
        # self.task_LineEdit.setCompleter(self.task_completer)

        # Initialize QCompleter for data_pathLineEdit
        self.data_path_completer = QCompleter(self.data_path_history, self)
        self.data_path_completer.setCaseSensitivity(Qt.CaseInsensitive)
        # self.data_pathLineEdit.setCompleter(self.data_path_completer)

        # # fIND THE PLACEHOLDER WIDGET
        placeholder = self.findChild(QWidget, 'placeholder_widget')
        placeholderLayout = placeholder.parentWidget().layout()

        #Add switch control
        self.switch_control = SwitchControl()
        # Reduce the size of the SwitchControl
        self.switch_control.setFixedSize(50, 25)  # Set the desired width and height
        # # Replace the placeholder with the layer tree view
        placeholderLayout.replaceWidget(placeholder, self.switch_control)

        # Connect the switch_control to the slot function
        self.switch_control.toggled.connect(self.toggle_data_path_line_edit)

        # Add a map view to display the solution graph
        self.web_view_layout = QVBoxLayout()
        self.web_view_layout.setContentsMargins(0, 0, 0, 0)
        self.graph_widget.setLayout(self.web_view_layout)
        self.web_view = QWebView()
        self.web_view_layout.addWidget(self.web_view)
        # self.graphview()

        # Add a map view to display reports
        self.report_web_view_layout = QVBoxLayout()
        self.report_web_view_layout.setContentsMargins(0, 0, 0, 0)
        self.report_widget.setLayout(self.report_web_view_layout)
        self.report_web_view = QWebView()
        self.report_web_view_layout.addWidget(self.report_web_view)
        # self.graphview()

        # Apply the syntax highlighter
        self.highlighter = PythonHighlighter(self.output_text_edit.document())

        # Set default workspace directory to plugin directory
        # current_script_dir = os.path.dirname(os.path.abspath(__file__))
        workspace_dir = os.path.join(current_script_dir, 'Default_workspace')
        self.workspace_directoryLineEdit.setPlainText(workspace_dir)


        # Connect button to open directory dialog
        self.select_workspace_Btn.clicked.connect(self.open_directory_dialog)


        # Connect the visibility changed signal for all layers
        root = QgsProject.instance().layerTreeRoot()
        root.visibilityChanged.connect(self.on_layer_visibility_changed)


    def show_contribution_dialog(self):
        """Open the ContributionDialog for user interaction."""

        self.contribution_dialog = ContributionDialog(self)

        self.contribution_dialog.exec_()



    # def open_upload_dialog(self):
    #     """ Open the custom dialog for uploading TOML files """
    #     dialog = UploadTomlDialog(self)
    #     dialog.exec_()  # Show the dialog

    def handle_missing_libraries(self, missing_packages):
        if missing_packages:
            message = "The following Python packages are required to use the plugin:\n\n"
            message += "\n".join(missing_packages)
            message += "\n\nWould you like to install them now? After installation, please restart QGIS."

            reply = QMessageBox.question(self, 'Missing Dependencies', message,
                                         QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
            if reply == QMessageBox.Yes:
                install_libraries(missing_packages)

    def check_libraries_once(self):

        """Check if libraries were already installed, otherwise run the check."""
        settings = QSettings('YourOrganization', 'YourApplication')
        libraries_checked = settings.value('libraries_checked', False, type=bool)

        if not libraries_checked:
            # First time: Libraries have not been checked
            print("Checking and installing required libraries...")
            from .install_packages.check_packages import check_and_install_libraries
            # Call your existing method to check and install libraries
            required_packages = os.path.join(os.path.dirname(__file__), 'install_packages', 'requirements.txt')
            check_and_install_libraries(required_packages)

            # Mark the libraries as checked and installed
            settings.setValue('libraries_checked', True)
        else:
            # Libraries have already been checked
            print("Libraries have already been checked and installed.")

    def import_libraries(self):
        """Dynamically import the third-party libraries after ensuring they're installed."""

        """Dynamically import the third-party libraries after ensuring they're installed."""
        global SwitchControl, QWebEngineView, OpenAI, nest_asyncio
        from QSwitchControl import SwitchControl
        from PyQt5.QtWebEngineWidgets import QWebEngineView
        # from PyQtWebEngine import QWebEngineView
        from openai import OpenAI
        import nest_asyncio


    def on_layer_visibility_changed(self):
        """Update data_pathLineEdit based on visible layers."""
        root = QgsProject.instance().layerTreeRoot()
        visible_layers = []

        # Traverse all layers and check their visibility
        for layer_node in root.findLayers():
            layer = layer_node.layer()  # Get the actual layer from the layer tree node

            if layer and layer_node.isVisible():  # Ensure the layer is valid and visible
                try:
                    layer_path = layer.dataProvider().dataSourceUri().split("|")[0]
                    visible_layers.append(layer_path)
                except AttributeError:
                    # Handle cases where dataSourceUri might not be available
                    continue


        # Update data_pathLineEdit with the paths of visible layers, each on a new line
        all_paths = "\n".join(visible_layers)

        self.data_pathLineEdit.setPlainText(all_paths)

    def on_layer_added(self, layer):
        # Get the current text in the LineEdit
        existing_paths = self.data_pathLineEdit.toPlainText()
        # Get the layer's data source and name it correctly
        # Ensure the data provider is not None before accessing dataSourceUri
        if layer.dataProvider() is not None:
            # Get the layer's data source path
            layer_path = layer.dataProvider().dataSourceUri().split("|")[0]

            # Append the new layer's path if it doesn't already exist
            if layer_path not in existing_paths:
                if existing_paths:
                    all_paths = existing_paths + "\n" + layer_path
                else:
                    all_paths = layer_path

                self.data_pathLineEdit.setPlainText(all_paths)

        # Connect the visibilityChanged signal for the newly added layer
        root = QgsProject.instance().layerTreeRoot()
        node = root.findLayer(layer.id())
        if node:
            node.visibilityChanged.connect(self.on_layer_visibility_changed)

    def on_layer_removed(self, layer_id):
        # Get the current text in the LineEdit
        existing_paths = self.data_pathLineEdit.toPlainText()

        # Get the layer's data source and name it correctly
        layer = QgsProject.instance().mapLayer(layer_id)
        if not layer:
            return

        # Initialize layer_path as None
        layer_path = None

        layer_path = layer.dataProvider().dataSourceUri().split("|")[0]

        if layer_path in existing_paths:
            # # Remove the path from the LineEdit
            # updated_paths = existing_paths.replace(layer_path, "").replace(";;", ";")
            # # Clean up leading/trailing semicolons
            # updated_paths = updated_paths.strip("; ")

            updated_paths = existing_paths.replace(layer_path, "").replace("\n\n", "\n")
            # Clean up leading/trailing newlines
            updated_paths = updated_paths.strip("\n")

            self.data_pathLineEdit.setPlainText(updated_paths)




        # Update data_pathLineEdit based on the remaining visible layers
        self.on_layer_visibility_changed()

    def toggle_data_path_line_edit(self, checked):
        """Enable or disable data_pathLineEdit based on the switch_control state."""
        self.data_pathLineEdit.setEnabled(not checked)
        self.loadData.setEnabled(not checked)

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def initUI(self):
        # Creat switch control
        switch_control = SwitchControl()
        self.switch_layout = QHBoxLayout()
        self.switch_layout.addWidget(switch_control, Qt.AlignCenter, Qt.AlignCenter)
        self.setLayout(self.switch_layout)

        # Disable the data_pathLineEdit permanently
        # self.data_pathLineEdit.setEnabled(False)
        self.run_button = self.findChild(QPushButton, 'run_button')
        # self.run_button.clicked.connect(self.run_script)
        self.run_button.clicked.connect(self.send_button_clicked)
        # self.run_button.clicked.connect(lambda: self.append_message(self.task_LineEdit.toPlainText()))
        # self.ESGpushButton.clicked.connect(self.run_slnGraph_script)sss
        self.interrupt_button.clicked.connect(self.interrupt)
        self.interrupt_button.clicked.connect(self.stop_script)
        # self.pushButton = self.findChild(QPushButton, 'pushButton')
        # self.SelectDataPath_ToolBtn.clicked.connect(self.openFileDialog)
        self.clear_textboxesBtn.clicked.connect(self.clear_textboxes)
        self.loadData.clicked.connect(self.load_data)
        self.refresh_slnGraph_Btn.clicked.connect(self.refresh_slnGraph)
        self.refresh_report_Btn.clicked.connect(self.refresh_report)
        self.add_document_button.clicked.connect(self.add_documentation_file)
        # self.add_document_github_button.clicked.connect(self.open_upload_dialog)
        self.add_document_github_button.clicked.connect(self.show_contribution_dialog)
        self.tabWidget.setCurrentIndex(0)

        # self.read_updated_config()
        # Populate data_pathLineEdit with currently loaded layers
        # self.populate_data_path_line_edit()
        self.on_layer_visibility_changed()

    def populate_data_path_line_edit(self):
        # Retrieve all layers currently in the project
        layers = QgsProject.instance().mapLayers().values()
        paths = []

        for layer in layers:
            layer_path = None
            # Check if the layer has a valid data provider
            data_provider = layer.dataProvider()
            if data_provider is not None:
                layer_path = data_provider.dataSourceUri().split("|")[0]
            # layer_path = layer.dataProvider().dataSourceUri().split("|")[0]

            # Handle vector layers
            if isinstance(layer, QgsVectorLayer):
                if layer.isValid() and layer.isTemporary():
                    paths.append(f"Temporary Layer: {layer.name()}")
                else:
                    paths.append(layer_path)

            # Handle raster layers
            elif isinstance(layer, QgsRasterLayer):
                if layer.isValid() and layer.isTemporary():
                    paths.append(f"Temporary Layer: {layer.name()}")
                else:
                    paths.append(layer_path)

            # Handle other types of layers if needed
            # Filter out any None values just in case
        paths = [path for path in paths if path is not None]
        # Join paths with a semicolon and update data_pathLineEdit
        all_paths = "; ".join(paths)
        self.data_pathLineEdit.setPlainText(all_paths)
    def read_updated_config(self):
        # self.update_config_file()
        current_script_dir = os.path.dirname(os.path.abspath(__file__))
        config_path = os.path.join(current_script_dir, 'SpatialAnalysisAgent', 'config.ini')
        # config_path = os.path.join(os.path.dirname(self.script_path), 'config.ini')
        config = configparser.ConfigParser()
        config.read(config_path)
        OpenAI_key = config['API_Key']['OpenAI_key']
        self.OpenAI_key_LineEdit.setText(OpenAI_key)

    def update_config_file(self):
        # Retrieve the API key from the line edit
        # OpenAI_key = self.OpenAI_key_LineEdit.text()
        current_script_dir = os.path.dirname(os.path.abspath(__file__))
        config_path = os.path.join(current_script_dir, 'SpatialAnalysisAgent', 'config.ini')
        # config_path = os.path.join(os.path.dirname(self.script_path), 'config.ini')
        # Ensure the directory exists, if not, create it
        config_dir = os.path.dirname(config_path)
        if not os.path.exists(config_dir):
            os.makedirs(config_dir)

        config = configparser.ConfigParser()

        # Check if the config file exists
        if os.path.exists(config_path):
            # If the config file exists, read the existing content
            config.read(config_path)

        if 'API_Key' not in config:
            config['API_Key'] = {}
            # Retrieve the API key from the line edit
        OpenAI_key= self.OpenAI_key_LineEdit.text().strip()
        config['API_Key']['OpenAI_key'] = OpenAI_key

        with open(config_path, 'w') as configfile:
            config.write(configfile)

        # # Update the QSettings (optional, if you want to store it there too)
        settings = QSettings('YourOrganization', 'YourApplication')
        settings.setValue('API_Key/OpenAI_key', OpenAI_key)

    def update_OpenAI_key(self):
        self.OpenAI_key = {}
        settings = QSettings('YourOrganization', 'YourApplication')
        api_key = self.OpenAI_key_LineEdit.text()
        # Store the key in the dictionary and save it in the QSettings
        self.OpenAI_key['OpenAI_key'] = api_key
        settings.setValue('API_Key/OpenAI_key', api_key)

    def load_OpenAI_key(self):
        # settings = QSettings('YourOrganization', 'YourApplication')
        # # Load the OpenAI key from QSettings
        # api_key = settings.value('API_Key/OpenAI_key', '')
        #
        # if api_key:
        #     # If the key is found in QSettings, set it in the LineEdit
        #     self.OpenAI_key_LineEdit.setText(api_key)
        # else:
        # Fallback to loading from the config file
        current_script_dir = os.path.dirname(os.path.abspath(__file__))
        config_path = os.path.join(current_script_dir, 'SpatialAnalysisAgent', 'config.ini')
        config = configparser.ConfigParser()
        if os.path.exists(config_path):
            config.read(config_path)
            if 'API_Key' in config and 'OpenAI_key' in config['API_Key']:
                api_key = config['API_Key']['OpenAI_key']
                self.OpenAI_key_LineEdit.setText(api_key)
        else:
            self.update_config_file()
    # # Set the loaded key in the OpenAI_key_LineEdit widget
    # self.OpenAI_key_LineEdit.setText(api_key)

    def update_graph(self, html_path):
        self.web_view.load(QUrl.fromLocalFile(html_path))

    def update_report(self, generated_report_path):
        self.report_web_view.load(QUrl.fromLocalFile(generated_report_path))

    def refresh_slnGraph(self):
        # Clear the web view content
        self.web_view.setHtml("<html><body><h1>Solution Graph Cleared</h1></body></html>")

    def refresh_report(self):
        self.report_web_view.setHtml("<html><body><h1>Reports Cleared</h1></body></html>")


    def set_initial_extent(self):
        project = QgsProject.instance()
        layers = list(project.mapLayers().values())
        if layers:
            extent = layers[0].extent()
            for layer in layers[1:]:
                extent.combineExtentWith(layer.extent())
            self.mapCanvas.setExtent(extent)

    def removeLayer(self):
        selectedIndex = self.layerTreeView.currentIndex()
        node = self.layerTreeModel.index2node(selectedIndex)
        if isinstance(node, QgsLayerTreeNode):
            QgsProject.instance().layerTreeRoot().removeChildNode(node)

    def showAttributeTable(self):
        selectedIndex = self.layerTreeView.currentIndex()
        node = self.layerTreeModel.index2node(selectedIndex)
        if node and isinstance(node, QgsLayerTreeNode):
            layer = node.layer()
            if layer:
                dlg = QgsAttributeDialog(layer)
                dlg.exec_()

    def zoomToExtent(self):
        selectedIndex = self.layerTreeView.currentIndex()
        node = self.layerTreeModel.index2node(selectedIndex)
        if node and isinstance(node, QgsLayerTreeNode):
            layer = node.layer()
            if layer:
                extent = layer.extent()
                self.mapCanvas.setExtent(extent)
                self.mapCanvas.refresh()

    def load_data(self):

        file_filter = "Vector files (*.shp *.csv *.xlsx *.gpkg);;Raster files (*.tif *.jpg)"
        data_paths, _ = QFileDialog.getOpenFileNames(self, "Open File", "", file_filter)
        if data_paths:
            # Get the current content of the data_pathLineEdit
            existing_paths = self.data_pathLineEdit.toPlainText()

            # Concatenate the new paths with the existing ones
            new_paths = "; ".join(data_paths)
            if existing_paths:
                # If there are already existing paths, add a semicolon before appending the new paths
                all_paths = existing_paths + "; " + new_paths
            else:
                # If there are no existing paths, just use the new paths
                all_paths = new_paths


            for data_path in data_paths:
                file_extension = os.path.splitext(data_path)[1].lower()

                if file_extension in ['.shp', '.csv', '.xlsx']:
                    # Extract the file name without the extension
                    layer_name = os.path.splitext(os.path.basename(data_path))[0]
                    # Load the vector data
                    layer = QgsVectorLayer(data_path, os.path.basename(layer_name), "ogr")
                    # Add the layer to the project
                    QgsProject.instance().addMapLayer(layer)
                    # self.data_pathLineEdit.appendPlainText(f"{data_path}")

                elif file_extension in ['.gpkg']:
                    # GPKG can contain multiple layers, so iterate over them
                    layers = QgsVectorLayer(data_path, '', 'ogr')
                    for layer_name in layers.dataProvider().subLayers():
                        layer_name = layer_name.split('!!::!!')[1]  # Extract the actual layer name
                        # Load each layer from the GPKG
                        layer = QgsVectorLayer(f"{data_path}|layername={layer_name}", layer_name, "ogr")
                        if layer.isValid():
                            # Add the layer to the project
                            QgsProject.instance().addMapLayer(layer)
                        else:
                            print(f"Failed to load GPKG layer: {layer_name} from {data_path}")

                elif file_extension in ['.tif', '.jpg']:
                    # Extract the file name without the extension
                    layer_name = os.path.splitext(os.path.basename(data_path))[0]
                    # Load the raster data
                    layer = QgsRasterLayer(data_path, os.path.basename(layer_name), "gdal")

                    # Add the raster layer to the project
                    QgsProject.instance().addMapLayer(layer)
                    # self.data_pathLineEdit.appendPlainText(f"{data_path}")

                else:
                    print("Unsupported file format!")

            # Set all paths in data_pathLineEdit separated by a semicolon
            self.data_pathLineEdit.setPlainText(all_paths)
    def send_button_clicked(self):
        """Slot to handle the send button click."""
        user_message =self.task_LineEdit.toPlainText().strip()

        if not user_message:
            self.update_chatgpt_ans(f"AI: Please enter a task in the task field.", is_user=False)
            return  # Stop further execution if the task is empty
        # print("Sending message:", self.task_LineEdit.toPlainText())  # Debugging statement
        # Emit the user's message in chatgpt_ans first
        self.append_message(user_message)

        # Call update_config_file to save the latest API key
        self.update_config_file()

        # Now read the updated config file to refresh the API key
        self.read_updated_config()

        if not self.switch_control.isChecked() and self.data_pathLineEdit.isEnabled() and not self.data_pathLineEdit.toPlainText().strip():
            self.update_chatgpt_ans(f"AI: Please load the data to be used.", is_user=False)
            return  # Stop further execution if data path is required but empty


        if self.switch_control.isChecked():  # Assuming SwitchControl behaves like a checkbox
            self.chatgpt_direct_answer(user_message)
        else:
            self.run_script()

    def chatgpt_direct_answer(self, user_message):
        """Method to interact with GPT-4 and display the result in output_text_edit_2."""
        # Update API key in the config file first
        # self.update_OpenAI_key()

        # Retrieve the API key from the config
        self.OpenAI_key = self.get_openai_key()  # This retrieves the latest key from the config

        # Emit the message from task_LineEdit first
        # user_message = self.task_LineEdit.toPlainText()
        self.OpenAI_key = self.get_openai_key()  # Retrieve the API key from the line edit
        self.model_name = self.modelNameComboBox.currentText()
        # if user_message.strip():  # Check if the input is not empty
        # self.update_output(f"User: {user_message}")  # Display the user message in output_text_edit_2

        # Start the GPT-4 request in a separate thread
        self.gpt_thread = GPTRequestThread(user_message, self.OpenAI_key, self.model_name, self.conversation_history)  # your-api-key-here
        # self.gpt_thread = GPTRequestThread(user_message, "AAzz", self.conversation_history)#your-api-key-here
        self.gpt_thread.output_line.connect(self.update_output)
        self.gpt_thread.finished_signal.connect(lambda:self.update_chatgpt_ans("AI: Done", is_user=False))

        self.gpt_thread.start()

    def open_directory_dialog(self):
        """Open a dialog for the user to select a workspace directory."""
        directory = QFileDialog.getExistingDirectory(self, "Select Workspace Directory")
        if directory:
            # Set the selected directory to the PlainTextLineEdit
            self.workspace_directoryLineEdit.setPlainText(directory)
    def run_script(self):
        # self.update_OpenAI_key()
        # Retrieve the API key from the config
        self.OpenAI_key = self.get_openai_key()  # This retrieves the latest key from the config
        current_script_dir = os.path.dirname(os.path.abspath(__file__))
        script_path = os.path.join(current_script_dir, "SpatialAnalysisAgent", "SpatialAnalysisAgent_MyScript.py")
        self.OpenAI_key = self.get_openai_key()  # Retrieve the API key from the line edit
        if not self.OpenAI_key:
            self.update_chatgpt_ans(f"AI: Please enter a valid OpenAI API key.", is_user=False)
            return
        self.model_name = self.modelNameComboBox.currentText()


        self.task = self.task_LineEdit.toPlainText()
        self.data_path = self.data_pathLineEdit.toPlainText()
        self.workspace_directory = self.workspace_directoryLineEdit.toPlainText()

        # Add task to history and update completer
        if self.task not in self.task_history:
            self.task_history.append(self.task)
            self.task_completer.model().setStringList(self.task_history)

        # Add data path to history and update completer
        if self.data_path not in self.data_path_history:
            self.data_path_history.append(self.data_path)
            self.data_path_completer.model().setStringList(self.data_path_history)

        self.thread = ScriptThread(script_path, self.task, self.data_path, self.workspace_directory, self.OpenAI_key, self.model_name)

        self.thread.output_line.connect(self.update_output)
        self.thread.graph_ready.connect(self.update_graph)
        self.thread.report_ready.connect(self.update_report)
        self.thread.chatgpt_update.connect(self.update_chatgpt_ans)
        self.thread.finished.connect(self.thread_finished)
        self.thread.start()

    def update_chatgpt_ans(self, message, is_user=False):
        # Append new message to conversation history
        self.conversation_history.append((message, is_user))
        self.chatgpt_ans.clear()
        for msg, user in self.conversation_history:
            self.append_text_with_format(msg, user)
            # self.chatgpt_ans.append(msg)
        self.chatgpt_ans.repaint()
        self.chatgpt_ans.verticalScrollBar().setValue(self.chatgpt_ans.verticalScrollBar().maximum())

    def stop_script(self):
        if self.thread:
            self.thread.terminate()
            self.update_chatgpt_ans(f"SpatialAnalysisAgent: Script terminated")
            # print("Script terminated")

    def append_text_with_format(self, text, is_user=True):
        cursor = self.chatgpt_ans.textCursor()
        cursor.movePosition(QTextCursor.End)

        if is_user:
            html = f'<div style="text-align: left; padding: 10px; margin: 5px; border: 2px solid blue; border-radius: 10px;">{text}</div>'
        else:
            html = f'<div style="text-align: right; padding: 10px; margin: 5px; border: 2px solid green; border-radius: 10px;">{text}</div>'

        cursor.insertHtml(html)
        cursor.insertHtml('<br>')  # Add a line break between messages
        # self.task_LineEdit.clear()

        self.chatgpt_ans.setTextCursor(cursor)

    @pyqtSlot(str)
    def append_message(self, message):
        # message = self.task_LineEdit.toPlainText()
        if message.strip():  # Check if message is not empty
            self.update_chatgpt_ans(f"User: {message}", is_user=True)
            self.update_output(f"User: {message}")
            if self.switch_control.isChecked():
                # Clear the input field after sending the message when switch is checked
                self.task_LineEdit.clear()

    def strip_ansi_sequences(self, text):
        ansi_escape = re.compile(r'\x1b\[[0-9;]*[A-Za-z]')
        return ansi_escape.sub('', text)

    def update_output(self, line):

        clean_line = self.strip_ansi_sequences(line)
        if "```python" in clean_line or "```" in clean_line:
            self.output_text_edit.insertPlainText(line)
        else:

            self.output_text_edit.insertPlainText(clean_line)
            # Conditionally add newline only if it is not already present
        if not clean_line.endswith('\n'):
            self.output_text_edit.insertPlainText('\n')
        # self.output_text_edit.insertPlainText('\n')  # Add a newline after each line
        self.output_text_edit.moveCursor(QTextCursor.End)  # Ensure cursor is at the end
        self.output_text_edit.repaint()
        # Move the scroll bar to the bottom to avoid unwanted gaps or large spaces
        self.output_text_edit.verticalScrollBar().setValue(self.output_text_edit.verticalScrollBar().maximum())

        # Check if the line contains the completion message
        if "-----Script completed-----" in clean_line:
            self.update_chatgpt_ans(f"AI: Done")

    def thread_finished(self, success):
        if success:
            # self.output_text_edit.append("The script ran successfully.")
            self.output_text_edit.insertPlainText("The script ran successfully.")
            self.update_chatgpt_ans(f"SpatialAnalysisAgent: Done")
        else:
            # self.output_text_edit.append("The script finished with errors.")
            self.output_text_edit.insertPlainText("The script finished with errors.")
            self.update_chatgpt_ans(f"SpatialAnalysisAgent: The script finished with errors.")

    def clear_textboxes(self):
        self.output_text_edit.clear()
        self.task_LineEdit.clear()
        self.chatgpt_ans.clear()
        # self.output_text_edit_2.clear()

    def interrupt(self):
        if self.thread:
            self.thread.stop()  # Call the stop method to set the flag

    def get_openai_key (self):
        api_key = self.OpenAI_key_LineEdit.text()
        if not api_key:
            raise ValueError("API key is empty. Please enter a valid OpenAI API key.")
        return api_key

    def add_documentation_file(self):
        # current_script_dir = os.path.dirname(os.path.abspath(__file__))
        # script_path = os.path.join(current_script_dir, "SpatialAnalysisAgent", "SpatialAnalysisAgent_MyScript.py")
        destination_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)),"SpatialAnalysisAgent", "Tools_Documentation")

        # Ensure the destination directory exists; if not, create it
        if not os.path.exists(destination_dir):
            os.makedirs(destination_dir)
        # Open file dialog to select .toml files
        files, _ = QFileDialog.getOpenFileNames(
            None, 'Select Documentation Files', '', 'TOML Files (*.toml)'
        )

        # If files are selected, process them
        if files:
            for file_path in files:
                # Determine the new path for the file in the destination directory
                new_file_path = os.path.join(destination_dir, os.path.basename(file_path))
                # Copy the file to the new directory
                shutil.copy(file_path, new_file_path)
                # print(f"File {file_path} copied to {new_file_path}")  # or update your UI to reflect the change

# The classFactory function must be placed at the end of this file
def classFactory(iface):
    """Load SpatialAnalysisAgentPlugin class."""
    return SpatialAnalysisAgentDockWidget(iface)


class ScriptThread(QThread):
    output_line = pyqtSignal(str)
    chatgpt_update = pyqtSignal(str)
    graph_ready = pyqtSignal(str)
    report_ready = pyqtSignal(str)
    finished = pyqtSignal(bool)

    def __init__(self, script_path, task, data_path, workspace_directory, OpenAI_key, model_name):
        super().__init__()
        self.script_path = script_path
        self.task = task
        self.data_path = data_path
        self.workspace_directory = workspace_directory
        self.OpenAI_key = OpenAI_key
        self.model_name = model_name

        self._is_running = True  # Flag to control the running state

    def run(self):

        try:
            # Update the config file with the API keys
            # self.update_config_file()

            # Ensure that the updated configuration is read by reloading the config
            config_path = os.path.join(os.path.dirname(self.script_path), 'SpatialAnalysisAgent', 'config.ini')
            config = configparser.ConfigParser()
            config.read(config_path)

            # Read the script content
            with open(self.script_path, "r") as script_file:
                script_content = script_file.read()

            local_vars = {

                'task': self.task,
                'data_path': self.data_path,
                'workspace_directory':self.workspace_directory,
                # 'OpenAI_key': self.OpenAI_key,
                'model_name': self.model_name,
                'check_running': self.check_running,
                '_is_running': self._is_running,
                'output_signal': self.chatgpt_update,  # Pass the chatgpt_update signal
            }

            # Redirect stdout and stderr to capture the output
            original_stdout = sys.stdout
            original_stderr = sys.stderr
            sys_stdout_capture = StringIO()
            sys_stderr_capture = StringIO()
            sys.stdout = sys_stdout_capture
            sys.stderr = sys_stderr_capture


            # Regular expression pattern to detect file paths
            path_pattern = r'[a-zA-Z]:[\\/][\S]+(?:\.html|\.png|\.jpg|\.pdf|\.txt|\.csv)'  # Add other extensions as needed

            def emit_output():
                sys_stdout_capture.flush()
                sys_stderr_capture.flush()
                captured_stdout = sys_stdout_capture.getvalue()
                captured_stderr = sys_stderr_capture.getvalue()
                sys_stdout_capture.truncate(0)
                sys_stderr_capture.truncate(0)
                sys_stdout_capture.seek(0)
                sys_stderr_capture.seek(0)

                if captured_stdout:
                    # self.output_line.emit(captured_stdout)
                    for line in captured_stdout.splitlines(keepends=True):
                        if line.endswith('\n'):
                            self.output_line.emit(line.rstrip())
                        else:
                            self.output_line.emit(line)
                    for line in captured_stdout.splitlines():
                        if "GRAPH_SAVED:" in line:
                            html_graph_path = line.split("GRAPH_SAVED:")[1].strip()
                            self.graph_ready.emit(html_graph_path)
                            self.chatgpt_update.emit("AI: Graph is ready.")  # Emit the message to chatgpt_ans

                        elif "Captured Output:" in line:  # Check for "Captured Output" flag
                            generated_output = line.split("Captured Output:")[1].strip()
                            # Check if generated output is not empty before emitting
                            if generated_output:
                                self.report_ready.emit(generated_output)
                                self.chatgpt_update.emit(f"AI: {generated_output}")  # Emit captured output
                if captured_stderr:
                    for line in captured_stderr.splitlines(keepends=True):
                        if line.endswith('\n'):
                            self.output_line.emit(f"Error: {line.rstrip()}")
                        else:
                            # handle the case where the line doesn't end with a newline
                            self.output_line.emit(f"Error: {line}")

            # Execute the script using exec
            exec_globals = globals()
            # exec_locals = locals()
            exec_locals = local_vars

            # This will allow for real-time capturing and emitting of output
            import threading
            stop_thread = threading.Event()

            def monitor_output():
                while not stop_thread.is_set():
                    emit_output()
                    time.sleep(0.1)  # Adjust sleep time as needed

            monitor_thread = threading.Thread(target=monitor_output)
            monitor_thread.start()

            try:
                exec(script_content, exec_globals, exec_locals)
                while self._is_running:
                    time.sleep(0.1)
                    if not self._is_running:
                        break
            finally:
                stop_thread.set()
                monitor_thread.join()

            # Emit any remaining output
            emit_output()

            # Restore original stdout and stderr
            sys.stdout = original_stdout
            sys.stderr = original_stderr

            # Emit success signal
            self.finished.emit(True)

        except Exception as e:
            # Print traceback error to the text_edit
            traceback_str = traceback.format_exc()
            self.output_line.emit(f"Error: {e}\n{traceback_str}")  # Emit any exceptions to the UI
            self.chatgpt_update.emit(f"AI: An error occured: {str(e)}\n{traceback_str}")
            self.finished.emit(False)  # Signal failure

    def stop(self):
        self._is_running = False


    def isRunning(self):
        return self._is_running

    def check_running(self):
        return self._is_running

    # def update_config_file(self):
    #     # Retrieve the API key from the line edit
    #     # OpenAI_key = self.OpenAI_key_LineEdit.text()
    #
    #     current_script_dir = os.path.dirname(os.path.abspath(__file__))
    #     config_path = os.path.join(current_script_dir, 'SpatialAnalysisAgent', 'config.ini')
    #     # config_path = os.path.join(os.path.dirname(self.script_path), 'config.ini')
    #     # Ensure the directory exists, if not, create it
    #     config_dir = os.path.dirname(config_path)
    #     if not os.path.exists(config_dir):
    #         os.makedirs(config_dir)
    #
    #     config = configparser.ConfigParser()
    #
    #     # Check if the config file exists
    #     if os.path.exists(config_path):
    #         # If the config file exists, read the existing content
    #         config.read(config_path)
    #
    #     if 'API_Key' not in config:
    #         config['API_Key'] = {}
    #
    #     config['API_Key']['OpenAI_key'] = self.OpenAI_key
    #
    #     with open(config_path, 'w') as configfile:
    #         config.write(configfile)
    #
    #     # # Update the QSettings (optional, if you want to store it there too)
    #     settings = QSettings('YourOrganization', 'YourApplication')
    #     settings.setValue('API_Key/OpenAI_key', self.OpenAI_key)

from openai import OpenAI
class GPTRequestThread(QThread):
    output_line = pyqtSignal(str)
    finished_signal = pyqtSignal()

    def __init__(self, prompt, OpenAI_key, model_name, conversation_history):
        super().__init__()
        self.prompt = prompt
        self.OpenAI_key = OpenAI_key
        self.model_name = model_name


    # def update_config_file(self):
    #     # Retrieve the API key from the line edit
    #     # OpenAI_key = self.OpenAI_key_LineEdit.text()
    #
    #     current_script_dir = os.path.dirname(os.path.abspath(__file__))
    #     config_path = os.path.join(current_script_dir, 'SpatialAnalysisAgent', 'config.ini')
    #     # config_path = os.path.join(os.path.dirname(self.script_path), 'config.ini')
    #     # Ensure the directory exists, if not, create it
    #     config_dir = os.path.dirname(config_path)
    #     if not os.path.exists(config_dir):
    #         os.makedirs(config_dir)
    #
    #     config = configparser.ConfigParser()
    #
    #     # Check if the config file exists
    #     if os.path.exists(config_path):
    #     # If the config file exists, read the existing content
    #         config.read(config_path)
    #
    #     if 'API_Key' not in config:
    #         config['API_Key'] = {}
    #
    #     config['API_Key']['OpenAI_key'] = self.OpenAI_key
    #
    #     with open(config_path, 'w') as configfile:
    #         config.write(configfile)
    #
    #     # # Update the QSettings (optional, if you want to store it there too)
    #     settings = QSettings('YourOrganization', 'YourApplication')
    #     settings.setValue('API_Key/OpenAI_key', self.OpenAI_key)


    def load_api_key_from_config(self):
        """Load OpenAI API key from config.ini."""
        current_script_dir = os.path.dirname(os.path.abspath(__file__))
        config_path = os.path.join(current_script_dir, 'SpatialAnalysisAgent', 'config.ini')

        config = configparser.ConfigParser()
        config.read(config_path)

        if 'API_Key' in config and 'OpenAI_key' in config['API_Key']:
            return config['API_Key']['OpenAI_key']
        else:
            raise ValueError("API Key not found in config file.")

    def run(self):
        try:
            # self.update_config_file()

            client = OpenAI(api_key=self.OpenAI_key)
            response = client.chat.completions.create(
                model= self.model_name,#"gpt-4",
                messages=[
                    {"role": "user", "content": self.prompt},
                ]
            )
            reply = response.choices[0].message.content.strip()
            self.output_line.emit(f"AI: {reply}")
        except Exception as e:
            self.output_line.emit(f"Error: {str(e)}")
        finally:
            self.finished_signal.emit()


class PythonHighlighter(QSyntaxHighlighter):
    def __init__(self, document):
        super(PythonHighlighter, self).__init__(document)
        self.python_block = False  # Initialize python_block as False

        # Define the syntax highlighting rules
        self.highlighting_rules = []

        # Keywords
        keyword_format = QTextCharFormat()
        keyword_format.setForeground(QColor("blue"))
        keywords = [
            "def", "class", "if", "else", "elif", "while", "for", "return", "import", "from", "as", "with", "try",
            "except", "finally", "raise", "yield", "lambda", "pass", "break", "continue", "global", "nonlocal",
            "assert", "del"
        ]
        for keyword in keywords:
            pattern = re.compile(r'\b' + keyword + r'\b')
            self.highlighting_rules.append((pattern, keyword_format))

        # Strings
        string_format = QTextCharFormat()
        string_format.setForeground(QColor("green"))
        self.highlighting_rules.append((re.compile(r'"[^"\\]*(\\.[^"\\]*)*"'), string_format))
        self.highlighting_rules.append((re.compile(r"'[^'\\]*(\\.[^'\\]*)*'"), string_format))

        # Comments
        comment_format = QTextCharFormat()
        comment_format.setForeground(QColor("gray"))
        self.highlighting_rules.append((re.compile(r'#.*'), comment_format))

    def highlightBlock(self, text):
        # for pattern, format in self.highlighting_rules:
        #     for match in pattern.finditer(text):
        #         start, end = match.span()
        #         self.setFormat(start, end - start, format)
        # Check if this block is the start or end of a Python code section
        if text.strip() == "```python":
            self.python_block = True
            return  # Don't highlight the marker line
        elif text.strip() == "```":
            self.python_block = False
            return  # Don't highlight the marker line

        # Apply syntax highlighting only if we're inside a Python block
        if self.python_block:
            for pattern, format in self.highlighting_rules:
                for match in pattern.finditer(text):
                    start, end = match.span()
                    self.setFormat(start, end - start, format)


# class UploadTomlDialog(QDialog):
#     def __init__(self, parent=None):
#         super().__init__(parent)
#
#         self.setWindowTitle("Upload TOML File to GitHub")
#         self.resize(400, 200)
#
#         layout = QVBoxLayout(self)
#
#         # File selection label and button
#         self.file_label = QLabel("No file selected")
#         self.select_file_button = QPushButton("Select TOML File")
#         self.select_file_button.clicked.connect(self.select_file)
#
#         # GitHub token input
#         self.token_input = QLineEdit()
#         self.token_input.setPlaceholderText("Enter GitHub Token (if needed)")
#
#         # Upload button
#         self.upload_button = QPushButton("Upload to GitHub")
#         self.upload_button.clicked.connect(self.upload_file)
#
#         # Add widgets to the layout
#         layout.addWidget(self.file_label)
#         layout.addWidget(self.select_file_button)
#         layout.addWidget(self.token_input)
#         layout.addWidget(self.upload_button)
#
#         self.selected_file = None
#
#     def select_file(self):
#         """ Open file dialog to select the TOML file """
#         file_dialog = QFileDialog()
#         toml_file, _ = file_dialog.getOpenFileName(self, "Select a TOML file", "", "TOML Files (*.toml)")
#
#         if toml_file:
#             self.selected_file = toml_file
#             self.file_label.setText(toml_file)
#
#
#     # def get_github_token(self):
#     #     # Path to the configuration file
#     #     current_script_dir = os.path.dirname(os.path.abspath(__file__))
#     #     githubtokenConfig_path = os.path.join(current_script_dir, "config_files", "GitHubTokenConfig.ini")
#     #
#     #     config = configparser.ConfigParser()
#     #
#     #     # Check if the config file exists
#     #     if os.path.exists(githubtokenConfig_path):
#     #         # If the config file exists, read the token from it
#     #         config.read(githubtokenConfig_path)
#     #         token = config.get("GitHub", "token", fallback=None)
#     #         if not token:
#     #             token = self.prompt_for_token(githubtokenConfig_path)
#     #         return token
#     #     else:
#     #         # If the config file doesn't exist, create it and prompt for token
#     #         os.makedirs(os.path.dirname(githubtokenConfig_path), exist_ok=True)
#     #         return self.prompt_for_token(githubtokenConfig_path)
#     #
#     # def prompt_for_token(self, config_file_path):
#     #     """Prompt the user for a GitHub token and store it in the config file."""
#     #     token, ok = QInputDialog.getText(self, 'GitHub Token', 'Please enter your GitHub token:')
#     #     if ok and token:
#     #         self.save_github_token(config_file_path, token)
#     #         return token
#     #     else:
#     #         return None
#     #
#     # def save_github_token(self, config_file_path, token):
#     #     """Save the GitHub token to the configuration file."""
#     #     config = configparser.ConfigParser()
#     #     config.read(config_file_path)
#     #     config["GitHub"] = {"token": token}
#     #
#     #     with open(config_file_path, "w") as config_file:
#     #         config.write(config_file)
#
#     def upload_file(self):
#         """ Trigger file upload logic """
#         if not self.selected_file:
#             QMessageBox.warning(self, "Error", "Please select a TOML file to upload.")
#             return
#
#         token = self.token_input.text().strip()
#
#         # Check if token is provided or already stored
#         if not token:
#             token = self.get_github_token()
#
#         if not token:
#             QMessageBox.warning(self, "Error", "GitHub token is required for the upload.")
#             return
#
#         # Upload file to GitHub
#         try:
#             upload_to_github(token, self.selected_file)
#             QMessageBox.information(self, "Success", "File successfully uploaded to GitHub.")
#         except Exception as e:
#             QMessageBox.warning(self, "Error", f"Failed to upload file: {str(e)}")
#
#
# # Function to upload the file to GitHub using the provided token and file
# def upload_to_github(token, file_path):
#     repo = "Teakinboyewa/SpatialAnalysisAgent"  # Hardcoded repository
#     FOLDER_IN_REPO = "SpatialAnalysisAgent"
#     path_in_repo = os.path.join(FOLDER_IN_REPO, os.path.basename(file_path))
#
#     # Prepare the request
#     url = f"https://api.github.com/repos/{repo}/contents/{path_in_repo}"
#     with open(file_path, 'rb') as file:
#         content = file.read()
#
#     encoded_content = base64.b64encode(content).decode("utf-8")
#
#     headers = {
#         "Authorization": f"token {token}",
#         "Accept": "application/vnd.github.v3+json"
#     }
#
#     data = {
#         "message": "Adding a new TOML file via QGIS plugin",
#         "content": encoded_content
#     }
#
#     response = requests.put(url, json=data, headers=headers)
#
#     if response.status_code == 201:
#         print("File successfully uploaded to GitHub.")
#     else:
#         print(f"Failed to upload file: {response.json()}")
#         raise Exception(f"GitHub upload failed: {response.json()}")


class ContributionDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.plugin = parent  # Reference to the main plugin class

        self.setWindowTitle("Contribute to SpatialAnalysisAgent")
        self.setMinimumWidth(400)

        self.setWindowTitle("Contribute to Spatial Analysis Agent")
        layout = QVBoxLayout(self)

        # Add a label for instructions
        instructions = QLabel("Instructions for contribution:")
        layout.addWidget(instructions)

        # Instructional label
        instructions = QLabel("""
        <h3>How to Contribute</h3>
        <ol>
            <li><b>Fork this repository</b> on GitHub: <a href='https://github.com/Teakinboyewa/SpatialAnalysisAgent'>Click Here</a>.</li>
            <li><b>Clone your fork</b> to your local machine.</li>
            <li>Upload a TOML file using this dialog (it will go to your forked repository).</li>
            <li>After uploading, go to GitHub and <b>open a pull request</b> from your fork to the main repository.</li>
        </ol>
        """)
        instructions.setOpenExternalLinks(True)
        layout.addWidget(instructions)

        # File upload button
        self.upload_button = QPushButton("Upload TOML File to Fork")
        self.upload_button.clicked.connect(self.upload_toml_file)
        layout.addWidget(self.upload_button)

    def get_github_token(self):
        """Retrieve the GitHub token from the config file or prompt the user to enter one."""

        # Path to the configuration file
        current_script_dir = os.path.dirname(os.path.abspath(__file__))
        githubtokenConfig_path = os.path.join(current_script_dir, "config_files", "GitHubTokenConfig.ini")

        config = configparser.ConfigParser()

        try:
            # Check if the config file exists
            if os.path.exists(githubtokenConfig_path):
                # If the config file exists, read the token from it
                config.read(githubtokenConfig_path)
                token = config.get("GitHub", "token", fallback=None)

                # If no token found, prompt for token
                if not token:
                    token = self.prompt_for_token(githubtokenConfig_path)
                return token

            else:
                # If the config file doesn't exist, create it and prompt for token
                os.makedirs(os.path.dirname(githubtokenConfig_path), exist_ok=True)
                return self.prompt_for_token(githubtokenConfig_path)

        except (configparser.Error, IOError) as e:
            QMessageBox.warning(self, "Error", f"Failed to read or write the token configuration: {e}")
            return None

    def prompt_for_token(self, config_file_path):
        """Prompt the user for a GitHub token and store it in the config file."""
        token, ok = QInputDialog.getText(self, 'GitHub Token', 'Please enter your GitHub token:')
        if ok and token:
            self.save_github_token(config_file_path, token)
            return token
        else:
            return None

    def save_github_token(self, config_file_path, token):
        """Save the GitHub token to the configuration file."""
        config = configparser.ConfigParser()
        config.read(config_file_path)
        config["GitHub"] = {"token": token}

        with open(config_file_path, "w") as config_file:
            config.write(config_file)

    def check_if_fork_exists(self, token, username):
        repo = "Teakinboyewa/SpatialAnalysisAgent"
        url = f"https://api.github.com/repos/{username}/SpatialAnalysisAgent"

        headers = {
            "Authorization": f"token {token}",
            "Accept": "application/vnd.github.v3+json"
        }

        response = requests.get(url, headers=headers)

        if response.status_code == 200:
            return True  # The fork exists
        else:
            return False

    def upload_to_user_fork(self, token, file_path, username):
        repo = f"{username}/SpatialAnalysisAgent"  # Target the user's fork
        FOLDER_IN_REPO = "SpatialAnalysisAgent"  # Folder inside the repo
        file_name =os.path.basename(file_path)
        path_in_repo = f"{FOLDER_IN_REPO}/{file_name}"
        url = f"https://api.github.com/repos/{repo}/contents/{path_in_repo}"


        with open(file_path, 'rb') as file:
            content = file.read()

        encoded_content = base64.b64encode(content).decode("utf-8")

        headers = {
            "Authorization": f"token {token}",

            "Accept": "application/vnd.github.v3+json"
        }

        data = {
            "message": "Adding a new TOML file via QGIS plugin",
            "content": encoded_content
        }

        response = requests.put(url, json=data, headers=headers)

        if response.status_code == 201:
            print("File successfully uploaded to the forked GitHub repository.")
        else:
            print(f"Failed to upload file: {response.json()}")
            raise Exception(f"GitHub upload failed: {response.json()}")

    def prompt_pull_request(self, username):
        pr_url = f"https://github.com/{username}/SpatialAnalysisAgent/compare"
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Information)
        msg.setText(
            f"File uploaded successfully to your fork.\nPlease open a pull request to merge it into the main repository.")
        msg.setInformativeText(f"<a href='{pr_url}'>Click here to open a pull request</a>")
        msg.setStandardButtons(QMessageBox.Ok)
        msg.exec_()

    def upload_toml_file(self):
        """Handle the file upload to the user's fork."""
        token = self.get_github_token()  # Get GitHub token from main plugin

        if not token:
            QMessageBox.warning(self, "Error", "GitHub token is required.")
            return

        # Prompt user to select a file
        file_dialog = QFileDialog(self)
        toml_file, _ = file_dialog.getOpenFileName(self, "Select a TOML file", "", "TOML Files (*.toml)")

        if toml_file:
            # Ask for GitHub username (you can automate this with the token if preferred)
            username, ok = QInputDialog.getText(self, 'GitHub Username', 'Enter your GitHub username:')

            if ok and username:
                # Upload the file to the user's fork
                self.upload_to_user_fork(token, toml_file, username)

                # Prompt the user to open a pull request
                self.prompt_pull_request(username)
            else:
                QMessageBox.warning(self, "Error", "GitHub username is required.")